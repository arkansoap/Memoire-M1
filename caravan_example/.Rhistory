Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
names(out) <- c("error", "accuracy", "FP/N", "FN/P", "kappa")
finalOut <- c(print(MatConf), table(out))
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
names(out) <- c("error", "accuracy", "FP/N", "FN/P", "kappa")
table(out)
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
names(out) <- c("error", "accuracy", "FP/N", "FN/P", "kappa")
kable(out)
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
names(out) <- c("error", "accuracy", "FP/N", "FN/P", "kappa")
print(kable(out))
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
names(out) <- c("error", "accuracy", "FP/N", "FN/P", "kappa")
out%>%kable()%>%kable_styling()
}
#changer notation P and N ? x= Y, y = prediction, z = realite
evoSeuil <- function(x,y,z){
N<-sum(z==1)
P<-sum(z==0)
Error<-NULL
ErrorI<-NULL
ErrorII<-NULL
for(i in 1:101){
c<-(i-1)/100
Prediction<-rep(1,nrow(z))
Prediction[y[,1]>c]<-0
Error[i]<-sum(Prediction!=x)/nrow(z)
ErrorI[i]<-sum((Prediction==0)&(x==1))/N
ErrorII[i]<-sum((Prediction==1)&(x==0))/P
}
par(cex=0.7)
plot((0:100)/100,Error,type="l",xlim=c(0,1),ylim=c(0,1),
ylab="Taux d'erreur",xlab="Seuil")
par(new=T)
plot((0:100)/100,ErrorI,type="l",xlim=c(0,1),ylim=c(0,1),
ylab="",xlab="",xaxt="n",yaxt="n",col="orange")
par(new=T)
plot((0:100)/100,ErrorII,type="l",xlim=c(0,1),ylim=c(0,1),ylab="",xlab="",xaxt="n",yaxt="n",col="blue",lty="dashed")
legend('topright', legend=c("Erreur ", "Erreur I", "Erreur 2"),
col=c("black","orange", "blue"), pch=15, bty="n", pt.cex=1, cex= 0.8, horiz=FALSE, inset=c(0.1,0.1))
title("Evolution des 3 types d'erreur")
}
#changer notation P and N ? x= Y, y = prediction, z = realite
evoSeuil <- function(x,y,z){
N<-sum(z==1)
P<-sum(z==0)
Error<-NULL
ErrorI<-NULL
ErrorII<-NULL
for(i in 1:101){
c<-(i-1)/100
Prediction<-rep(1,nrow(z))
Prediction[y[,1]>c]<-0
Error[i]<-sum(Prediction!=x)/nrow(z)
ErrorI[i]<-sum((Prediction==0)&(x==1))/N
ErrorII[i]<-sum((Prediction==1)&(x==0))/P
}
par(cex=0.7)
plot((0:100)/100,Error,type="l",xlim=c(0,1),ylim=c(0,1),
ylab="Taux d'erreur",xlab="Seuil")
par(new=T)
plot((0:100)/100,ErrorI,type="l",xlim=c(0,1),ylim=c(0,1),
ylab="",xlab="",xaxt="n",yaxt="n",col="orange")
par(new=T)
plot((0:100)/100,ErrorII,type="l",xlim=c(0,1),ylim=c(0,1),ylab="",xlab="",xaxt="n",yaxt="n",col="blue",lty="dashed")
legend('topright', legend=c("Erreur ", "Erreur I", "Erreur 2"),
col=c("black","orange", "blue"), pch=15, bty="n", pt.cex=1, cex= 0.8, horiz=FALSE, inset=c(0.1,0.1))
title("Evolution des 3 types d'erreur")
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
names(out) <- c("error", "accuracy", "FP/N", "FN/P", "kappa")
value <- out%>%kable()%>%kable_styling()
print(value)
print(MatConf)
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
names(out) <- c("error", "accuracy", "FP/N", "FN/P", "kappa")
perfM <- out%>%kable(caption = "Performance measures")%>%kable_styling()
print(perfM)
print(MatConf)
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
names(out) <- c("error", "accuracy", "FP/N", "FN/P", "kappa")
colnames(out)<- value
perfM <- out%>%kable(caption = "Performance measures")%>%kable_styling()
print(perfM)
print(MatConf)
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
names(out) <- c("error", "accuracy", "FP/N", "FN/P", "kappa")
colnames(out)<- "value"
perfM <- out%>%kable(caption = "Performance measures")%>%kable_styling()
print(perfM)
print(MatConf)
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
names(out) <- c("error", "accuracy", "FP/N", "FN/P", "kappa")
colnames(out) = "value"
perfM <- out%>%kable(caption = "Performance measures")%>%kable_styling()
print(perfM)
print(MatConf)
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
perfM <- out%>%kable(caption = "Performance measures",
col.names = c("error", "accuracy",
"FP/N", "FN/P", "kappa"),
row.names = "value")%>%kable_styling()
print(perfM)
print(MatConf)
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
perfM <- out%>%kable(caption = "Performance measures",
col.names = c("error", "accuracy",
"FP/N", "FN/P", "kappa"),
row.names = c("value"))%>%kable_styling()
print(perfM)
print(MatConf)
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
perfM <- out%>%kable(caption = "Performance measures",
col.names = c("error", "accuracy",
"FP/N", "FN/P", "kappa"),
row.name = "value")%>%kable_styling()
print(perfM)
print(MatConf)
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
perfM <- out %>% kable(caption = "Performance measures",
col.names = c("error", "accuracy",
"FP/N", "FN/P", "kappa"),
row.name = "value") %>% kable_styling()
print(perfM)
print(MatConf)
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
perfM <- out %>% kable(caption = "Performance measures",
row.names = c("error", "accuracy",
"FP/N", "FN/P", "kappa"),
col.names = "value") %>% kable_styling()
print(perfM)
print(MatConf)
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
perfM <- out %>% kable(caption = "Performance measures",
row.names = c("error", "accuracy",
"FP/N", "FN/P", "kappa"),
col.names = "value") %>% kable_styling()
print(perfM)
print(MatConf)
}
#changer notation P and N ? x= Y, y = prediction, z = realite
evoSeuil <- function(x,y,z){
N<-sum(z==1)
P<-sum(z==0)
Error<-NULL
ErrorI<-NULL
ErrorII<-NULL
for(i in 1:101){
c<-(i-1)/100
Prediction<-rep(1,nrow(z))
Prediction[y[,1]>c]<-0
Error[i]<-sum(Prediction!=x)/nrow(z)
ErrorI[i]<-sum((Prediction==0)&(x==1))/N
ErrorII[i]<-sum((Prediction==1)&(x==0))/P
}
par(cex=0.7)
plot((0:100)/100,Error,type="l",xlim=c(0,1),ylim=c(0,1),
ylab="Taux d'erreur",xlab="Seuil")
par(new=T)
plot((0:100)/100,ErrorI,type="l",xlim=c(0,1),ylim=c(0,1),
ylab="",xlab="",xaxt="n",yaxt="n",col="orange")
par(new=T)
plot((0:100)/100,ErrorII,type="l",xlim=c(0,1),ylim=c(0,1),ylab="",xlab="",xaxt="n",yaxt="n",col="blue",lty="dashed")
legend('topright', legend=c("Erreur ", "Erreur I", "Erreur 2"),
col=c("black","orange", "blue"), pch=15, bty="n", pt.cex=1, cex= 0.8, horiz=FALSE, inset=c(0.1,0.1))
title("Evolution des 3 types d'erreur")
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
perf.measure <- function(pred ,realCl, real )
{
MatConf <- table(pred,realCl) %>% addmargins %>%
kable(caption = "matrice de confusion")%>% kable_styling
P <- sum(realCl==1)
N <- sum(realCl==0)
n <- P+N
Pp <- sum(pred==1)
Np <- sum(pred==0)
Pre <- (((N*Np)/n)+((P*Pp)/n))/n
Pra <- sum((pred==0)&(real==0))+sum((pred==1)&(real==1))/n
kappa <- (pra - pre)/(1 - pre)
error <- sum(pred!=realCl)/nrow(real)
FPrate <- sum((pred==1)&(real==0))/N
FNrate <- sum((pred==0)&(real==1))/P
accuracy <- 1 - error
out <- c(error, accuracy, FPrate, FNrate, kappa)
names(out) <- c("error", "accuracy", "FP/N", "FN/P", "kappa")
perfM <- out%>%kable(caption = "Performance measures",
col.names = "value") %>% kable_styling()
print(perfM)
print(MatConf)
}
perf.measure(predLda$class, test.transformed$popularity, test.transformed)
confusionMatrix(predLda$class, test.transformed$popularity)
pred <- prediction(predLda$posterior[,2], test.transformed$popularity)
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
plot(perf, col=rainbow(10))
segments(0,0,1,1)
perf<-performance(pred,"auc");perf@y.values[[1]]
# x= Y, y = prediction, z = realite, S = seuil
changeSeuil <- function(x,y,z,S){
change_seuil<-rep(1,nrow(z))
change_seuil[y[,1]>S]<-0
round(prop.table(table(x,change_seuil),margin=1)*100,1)%>%
kable(caption = "Matrice de confusion avec le nouveau seuil") %>%
kable_styling()
}
changeSeuil(test.transformed$popularity, predLda$posterior,test.transformed,0.8)
RocAuc <- function(predpost, realite){
pred <- prediction(post[,2], realite)
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
plot(perf, col=rainbow(10))
segments(0,0,1,1)
perf<-performance(pred,"auc");perf@y.values[[1]]
}
#test fonction courbe roc
RocAuc(predLda$posterior, test.transformed$popularity)
RocAuc <- function(predpost, realite){
pred <- prediction(predpost[,2], realite)
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
plot(perf, col=rainbow(10))
segments(0,0,1,1)
perf<-performance(pred,"auc");perf@y.values[[1]]
}
#test fonction courbe roc
RocAuc(predLda$posterior, test.transformed$popularity)
# Avec proc
# Pourquoi pas la même qu'au dessus ?????????????
# control and case group ????? (rapport avec réalité et prédiction / levels?)
rocLDA <- roc(test.transformed$popularity, ordered(predLda$class))
plot(rocLDA)
rocLDA$auc
save.image("C:/Users/arkan/Desktop/Memoire-M1/applications_R/datSpot.RData")
